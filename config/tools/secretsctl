#!/usr/bin/env bash
# logs: syslog(logger) or /var/log/secretsctl.log if logger absent
# ==============================================================================
# secretsctl — age/agenix secret map & rotation helper for NixOS
# ==============================================================================
# PURPOSE
#   Manage age-encrypted secret blobs referenced by a host-local map for Agenix.
#   Includes safe rotation with “break-glass” key verification and recipient
#   union (device + break-glass + extras). Plaintext only lives in /dev/shm.
#
# MAP (HOST-LOCAL, NOT IN GIT) — AUTO-DISCOVERY
#   Order:
#     1) $SECRETSCTL_MAP (if set) or --map <path>
#     2) First existing of:
#          /srv/nixserver/manifests/secrets-map.json
#          /etc/nixos/secrets-map.json
#          /var/lib/agenix/secrets-map.json
#     3) If none exist, created at /srv/nixserver/manifests/secrets-map.json (or --map).
#   Schema: { "<name>": { "agePath": "/var/lib/agenix/<name>.age",
#                          "mode"?: "0400", "owner"?: "root", "group"?: "root" } }
#
# FILES
#   • Encrypted blobs:              /var/lib/agenix/<name>.age
#   • Device private identity:      /etc/agenix/key.txt (0600)
#       NOTE: key.txt contains comment lines from age-keygen — KEEP THEM.
#   • Combined recipients (pubs):   /etc/agenix/public.age (0644)
#   • Break-glass pubs (one/line):  /etc/agenix/breaking-glass.public.age (0644)
#
# CRITICAL POLICY
#   • Break-glass PUBLIC key(s) are a permanent safety net and should remain in
#     every rotation by default. Rotation verifies the provided break-glass
#     PRIVATE matches an entry in breaking-glass.public.age.
#   • Rotation rewraps every blob: decrypt with old identities, re-encrypt to
#     the combined recipients. Any failure → non-zero exit.
#
# SAFETY / ATOMICITY
#   • Map writes: flock + temp → mv (atomic).
#   • Plaintext in /dev/shm only; temp files shredded.
#   • Prompted break-glass key is stored in /dev/shm then wiped (also on abort).
#
# SUBCOMMANDS
#   secretsctl [--map <path>] <subcommand>
#     add [--stdin|--from-file <p>|--edit]
#         [--hash-sha512 | --hash-yescrypt | --htpasswd <user>]
#         [--commit] [--switch] [--flake <uri>] <name>
#     rm <name> | list | rename <old> <new>
#     export [--output <p>] [--include-keys] [--force]
#     import --identity <key.txt> <export.tar.age> [--replace-keys] [--force]
#     commit [--switch] [--flake <uri>]
#     check [--break-key <path>] [--fail-fast]
#     rotate [--verify-break <path>] [--generate-identity] [--force]
#            [--include-break|--no-include-break]
#            [--extra-recipient <age1..>]... [--extra-recipient-file <file>]
#            [--old-identity <path>]... [--switch] [--flake <uri>]
#
# TYPICAL ROTATION
#   sudo ./secretsctl rotate --verify-break /dev/shm/test.key \
#        --generate-identity --force --include-break --switch
#
# NixOS AGENIX INTEGRATION
#   age.identityPaths = [ "/etc/agenix/key.txt" ];
#   Decrypted files appear at /run/agenix/<name> during activation.
# ==============================================================================

set -Eeuo pipefail
IFS=$'\n\t'

# ---------- configuration ----------
MAP_DEFAULT="/srv/nixserver/manifests/secrets-map.json"
MAP_CANDIDATES=(
  "/srv/nixserver/manifests/secrets-map.json"
  "/etc/nixos/secrets-map.json"
  "/var/lib/agenix/secrets-map.json"
)
MAP="${SECRETSCTL_MAP-}"

DEST_DIR="/var/lib/agenix"
PUB_COMBINED="/etc/agenix/public.age"
PUB_BREAK="/etc/agenix/breaking-glass.public.age"
PRIV_DEVICE="/etc/agenix/key.txt"
LOCK="/run/lock/secretsctl.map.lock"
RAMTMP="/dev/shm"

MODE_BITS_DEFAULT="0400"
OWNER_DEFAULT="root"
GROUP_DEFAULT="root"

# ---------- helpers ----------
die() { printf 'error: %s\n' "$*" >&2; exit 2; }
need() { command -v "$1" >/dev/null 2>&1 || die "missing dependency: $1"; }
ensure_dirs() {
  install -d -m 700 "$RAMTMP"
  install -d -m 700 /etc/agenix
  install -d -m 700 "$DEST_DIR"
  install -d -m 755 /run/lock || true
}
sanitize_name() { [[ "${1:-}" =~ ^[A-Za-z0-9._-]+$ ]] || die "bad secret name: ${1:-}"; }
user_home() {
  if [[ -n "${SUDO_USER-}" && "$SUDO_USER" != "root" ]]; then
    local uh; uh="$(getent passwd "$SUDO_USER" 2>/dev/null | cut -d: -f6 || true)"
    [[ -n "$uh" ]] || uh="$(eval echo "~$SUDO_USER")"
    echo "$uh"
  else
    echo "${HOME:-/root}"
  fi
}
hash_name() { printf '%s' "$1" | sha256sum | awk '{print $1}' | cut -c1-16; }

resolve_map() {
  if [[ -n "${MAP:-}" ]]; then echo "$MAP"; return 0; fi
  for cand in "${MAP_CANDIDATES[@]}"; do
    if [[ -f "$cand" ]]; then MAP="$cand"; echo "$MAP"; return 0; fi
  done
  MAP="$MAP_DEFAULT"; echo "$MAP"
}

# Execute a command while holding the map lock
with_lock() { exec 9>"$LOCK"; flock -x 9; "$@"; local rc=$?; flock -u 9; return $rc; }

validate_or_init_map() {
  resolve_map >/dev/null 2>&1 || true
  local dir; dir="$(dirname "$MAP")"
  if [[ ! -f "$MAP" ]]; then
    install -d -m 700 "$dir"
    echo '{}' > "$MAP"
    chmod 0644 "$MAP"; chown root:root "$MAP" || true
    return
  fi
  jq -e '
    type=="object" and
    (to_entries | all(
      (.key|type=="string" and test("^[A-Za-z0-9._-]+$")) and
      (.value|type=="object" and
        (.agePath|type=="string" and (.agePath|startswith("/"))) and
        (if has("mode")  then (.mode  |type=="string") else true end) and
        (if has("owner") then (.owner |type=="string") else true end) and
        (if has("group") then (.group |type=="string") else true end)
      )
    ))
  ' "$MAP" >/dev/null 2>&1 || echo '{}' > "$MAP"
}

merge_map_entry() { # <name> <agePath> [mode owner group]
  local name="$1" path="$2" mode="${3:-$MODE_BITS_DEFAULT}" owner="${4:-$OWNER_DEFAULT}" group="${5:-$GROUP_DEFAULT}"
  local tmp; tmp="$(mktemp -p "$RAMTMP")"
  jq --arg n "$name" --arg p "$path" --arg m "$mode" --arg o "$owner" --arg g "$group" \
     ' .[$n] = {agePath:$p, mode:$m, owner:$o, group:$g} ' "$MAP" > "$tmp"
  mv -f "$tmp" "$MAP"
}

remove_map_entry() { # <name>
  local name="$1" tmp; tmp="$(mktemp -p "$RAMTMP")"
  jq --arg n "$name" ' del(.[$n]) ' "$MAP" > "$tmp"
  mv -f "$tmp" "$MAP"
}

# Accept both labeled & bare outputs from age-keygen -y
derive_pub_from_priv() { # <priv-path>
  local out
  out="$(age-keygen -y "$1" 2>/dev/null)" || return 1
  out="$(printf '%s\n' "$out" | awk '/^public key:/ {print $3; exit} /^age1/ {print $1; exit}')"
  [[ -n "$out" ]] || return 2
  printf '%s\n' "$out"
}

encrypt_to_file() { # <plaintext> <outfile>
  local src="$1" out="$2"
  if [[ -s "$PUB_COMBINED" ]]; then
    age -a -R "$PUB_COMBINED" -o "$out" < "$src"
  elif [[ -f "$PRIV_DEVICE" ]]; then
    local r; r="$(derive_pub_from_priv "$PRIV_DEVICE")"
    age -a -r "$r" -o "$out" < "$src"
  else
    die "no recipients: provide $PUB_COMBINED or $PRIV_DEVICE"
  fi
  chmod 0600 "$out"; chown root:root "$out" || true
}

do_commit() { # [--switch] [--flake <uri-or-path>]
  local mode="test" flake=""
  while [[ $# -gt 0 ]]; do
    case "$1" in
      --switch) mode="switch"; shift ;;
      --flake)  flake="${2:-}"; shift 2 ;;
      *) break ;;
    esac
  done
  local cmd=(nixos-rebuild "$mode")
  if [[ -n "$flake" ]]; then
    cmd+=(--flake "$flake")
  elif [[ -f /etc/nixos/flake.nix ]]; then
    cmd+=(--flake /etc/nixos)
  fi
  "${cmd[@]}"
}

# Prompt for a break-glass private key OR a file path; returns $BREAK_KEY_TMP
get_break_key() {
  local prompt="Break-glass private key (paste AGE-SECRET-KEY-1… or enter path to key file):"
  local input
  BREAK_KEY_TMP=""
  trap '[[ -n "$BREAK_KEY_TMP" && -f "$BREAK_KEY_TMP" && "$BREAK_KEY_TMP" == /dev/shm/tmp.* ]] && shred -u "$BREAK_KEY_TMP" 2>/dev/null || rm -f "$BREAK_KEY_TMP" || true' RETURN
  if command -v systemd-ask-password >/dev/null 2>&1; then
    input="$(systemd-ask-password "$prompt")" || return 1
  else
    read -rs -p "$prompt " input || { echo; return 1; }
    echo
  fi
  input="$(printf '%s' "$input" | tr -d '\r')"
  if [[ "$input" =~ ^AGE-SECRET-KEY-1 ]]; then
    BREAK_KEY_TMP="$(mktemp -p "$RAMTMP")"; umask 077
    printf '%s\n' "$input" > "$BREAK_KEY_TMP"; chmod 600 "$BREAK_KEY_TMP"
  else
    local path="$input"
    [[ "$path" == "~/"* ]] && path="${HOME%/}/${path#~/}"
    [[ -f "$path" ]] || { echo "error: not a readable path or AGE-SECRET-KEY: $path" >&2; return 2; }
    BREAK_KEY_TMP="$path"
  fi
  local test_pub; test_pub="$(derive_pub_from_priv "$BREAK_KEY_TMP" 2>/dev/null || true)"
  [[ -n "$test_pub" ]] || { echo "error: could not derive public from provided input/file" >&2; return 3; }
  trap - RETURN
  return 0
}

# ---------- subcommands ----------

cmd_add() { # add [--ask|--stdin|--from-file P|--edit] [--confirm] [--hash-*|--htpasswd USER] [--commit] [--switch] [--flake FLAKE] <name>
  local mode="stdin" src="" transform="plain" htuser="" do_commit_flag=0 commit_switch=0 commit_flake=""
  local ask=0 confirm=0
  while [[ $# -gt 0 ]]; do
    case "$1" in
      --ask) ask=1; mode="ask"; shift ;;
      --confirm) confirm=1; shift ;;
      --stdin|"") mode="stdin"; shift || true ;;
      --from-file) mode="file"; src="${2:-}"; [[ -n "$src" ]] || die "need a path"; shift 2 ;;
      --edit) mode="edit"; shift ;;
      --hash-sha512) transform="hash-sha512"; shift ;;
      --hash-yescrypt) transform="hash-yescrypt"; shift ;;
      --htpasswd) transform="htpasswd"; htuser="${2:-}"; [[ -n "$htuser" ]] || die "need user"; shift 2 ;;
      --commit) do_commit_flag=1; shift ;;
      --switch) commit_switch=1; shift ;;
      --flake) commit_flake="${2:-}"; shift 2 ;;
      *) break ;;
    esac
  done
  local name="${1:-}"; [[ -n "$name" ]] || die "missing <name>"; sanitize_name "$name"
  ensure_dirs; validate_or_init_map

  local pt; pt="$(mktemp -p "$RAMTMP")"; trap 'shred -u "$pt" 2>/dev/null || rm -f "$pt"' RETURN
  umask 077
  case "$mode" in
    ask)
      local s1 s2
      if command -v systemd-ask-password >/dev/null 2>&1; then
        s1="$(systemd-ask-password "Secret for ${name}:")" || die "input aborted"
        if [[ $confirm -eq 1 ]]; then
          s2="$(systemd-ask-password "Confirm secret for ${name}:")" || die "input aborted"
          [[ "$s1" == "$s2" ]] || die "mismatch between entries"
        fi
        printf '%s' "$s1" > "$pt"
      else
        read -rsp "Secret for ${name}: " s1; echo
        if [[ $confirm -eq 1 ]]; then
          read -rsp "Confirm secret for ${name}: " s2; echo
          [[ "$s1" == "$s2" ]] || die "mismatch between entries"
        fi
        printf '%s' "$s1" > "$pt"
      fi
      ;;
    stdin)
      cat > "$pt"
      ;;
    file)
      [[ -f "$src" ]] || die "no such file: $src"
      cat "$src" > "$pt"
      ;;
    edit)
      : > "$pt"; "${EDITOR:-vi}" "$pt" || die "editor aborted"
      ;;
  esac

  local payload; payload="$(mktemp -p "$RAMTMP")"; trap 'shred -u "$payload" 2>/dev/null || rm -f "$payload"' RETURN
  case "$transform" in
    plain) cp -f "$pt" "$payload" ;;
    hash-sha512) need openssl; openssl passwd -6 -stdin < "$pt" > "$payload" ;;
    hash-yescrypt) command -v mkpasswd >/dev/null 2>&1 || need mkpasswd; mkpasswd -m yescrypt -s < "$pt" > "$payload" ;;
    htpasswd) command -v htpasswd >/dev/null 2>&1 || need htpasswd; htpasswd -niB "$htuser" < "$pt" > "$payload" ;;
  esac

  local outtmp dst
  outtmp="$(mktemp -p "$RAMTMP")"; trap 'shred -u "$outtmp" 2>/dev/null || rm -f "$outtmp"' RETURN
  encrypt_to_file "$payload" "$outtmp"
  dst="$DEST_DIR/$name.age"; mv -f "$outtmp" "$dst"
  with_lock merge_map_entry "$name" "$dst"
  printf 'OK: added %s\n' "$name"

  if [[ $do_commit_flag -eq 1 ]]; then
    if [[ -n "$commit_flake" ]]; then
      if [[ $commit_switch -eq 1 ]]; then do_commit --switch --flake "$commit_flake"; else do_commit --flake "$commit_flake"; fi
    else
      if [[ $commit_switch -eq 1 ]]; then do_commit --switch; else do_commit; fi
    fi
  fi
}

cmd_gen_ssh() { # gen-ssh --name <secret-name> [--comment <ssh-comment>] [--type ed25519|rsa] [--bits N] [--pub-out <path>] [--commit] [--switch] [--flake <uri>]
  local name="" comment="" type="ed25519" bits="" pub_out="" do_commit_flag=0 commit_switch=0 commit_flake=""
  while [[ $# -gt 0 ]]; do
    case "$1" in
      --name) name="${2:-}"; shift 2 ;;
      --comment) comment="${2:-}"; shift 2 ;;
      --type) type="${2:-}"; shift 2 ;;
      --bits) bits="${2:-}"; shift 2 ;;
      --pub-out) pub_out="${2:-}"; shift 2 ;;
      --commit) do_commit_flag=1; shift ;;
      --switch) commit_switch=1; shift ;;
      --flake) commit_flake="${2:-}"; shift 2 ;;
      *) break ;;
    esac
  done
  [[ -n "$name" ]] || die "gen-ssh: --name <secret-name> is required"
  sanitize_name "$name"
  ensure_dirs; validate_or_init_map; need ssh-keygen

  # 1) generate SSH keypair in RAM (no passphrase)
  local tmpd; tmpd="$(mktemp -d -p "$RAMTMP")"; umask 077
  local key="$tmpd/id_${type}"
  if [[ "$type" == "rsa" && -n "$bits" ]]; then
    ssh-keygen -q -t rsa -b "$bits" -N "" -C "${comment}" -f "$key"
  elif [[ "$type" == "rsa" ]]; then
    ssh-keygen -q -t rsa -b 3072 -N "" -C "${comment}" -f "$key"
  else
    ssh-keygen -q -t ed25519 -N "" -C "${comment}" -f "$key"
  fi

  # 2) encrypt the PRIVATE key to .age and store
  local outtmp dst
  outtmp="$(mktemp -p "$RAMTMP")"
  encrypt_to_file "$key" "$outtmp"
  dst="$DEST_DIR/$name.age"; mv -f "$outtmp" "$dst"; chmod 600 "$dst"

  # 3) map entry (defaults)
  with_lock merge_map_entry "$name" "$dst"

  # 4) output / store PUBLIC key
  if [[ -n "$pub_out" ]]; then
    install -m 0644 "$key.pub" "$pub_out"
    echo "Public key written to: $pub_out"
  fi
  echo "Public key:"
  cat "$key.pub"

  # cleanup private material
  shred -u "$key" 2>/dev/null || rm -f "$key"
  rm -rf "$tmpd"

  echo "OK: SSH key generated; private encrypted at $dst; map updated"

  # optional rebuild
  if [[ $do_commit_flag -eq 1 ]]; then
    if [[ -n "$commit_flake" ]]; then
      if [[ $commit_switch -eq 1 ]]; then do_commit --switch --flake "$commit_flake"; else do_commit --flake "$commit_flake"; fi
    else
      if [[ $commit_switch -eq 1 ]]; then do_commit --switch; else do_commit; fi
    fi
  fi
}

cmd_rm() { # rm <name>
  local name="${1:-}"; [[ -n "$name" ]] || die "missing <name>"; sanitize_name "$name"
  ensure_dirs; validate_or_init_map
  with_lock remove_map_entry "$name"
  rm -f -- "$DEST_DIR/$name.age"
  printf 'OK: removed %s\n' "$name"
}

cmd_list() { # list
  ensure_dirs; validate_or_init_map
  jq -r '
    to_entries | sort_by(.key)[] |
    "\(.key)\t\(.value.agePath)\tmode=\(.value.mode//"") owner=\(.value.owner//"") group=\(.value.group//"")"
  ' "$MAP" | column -t -s $'\t' || true
}

cmd_rename() { # rename <old> <new>
  local old="${1:-}" new="${2:-}"
  [[ -n "$old" && -n "$new" ]] || die "usage: rename <old> <new>"
  sanitize_name "$old"; sanitize_name "$new"
  ensure_dirs; validate_or_init_map
  local oldpath="$DEST_DIR/$old.age" newpath="$DEST_DIR/$new.age"
  [[ -e "$oldpath" ]] || die "no such secret blob: $oldpath"
  [[ ! -e "$newpath" ]] || die "destination blob exists: $newpath"
  mv "$oldpath" "$newpath"

  with_lock bash -lc '
    set -euo pipefail
    tmp="$(mktemp -p "'"$RAMTMP"'")"
    jq --arg o "'"$old"'" --arg n "'"$new"'" --arg p "'"$newpath"'" \
       '"'"' .[$n] = (.[$o] // {})
              | .[$n].agePath = $p
              | del(.[$o]) '"'"' \
       "'"$MAP"'" > "$tmp"
    mv -f "$tmp" "'"$MAP"'"
  '
  printf 'OK: renamed %s -> %s\n' "$old" "$new"
}

cmd_export() { # export …
  local out="" include_keys=0 force=0
  while [[ $# -gt 0 ]]; do
    case "$1" in
      --output) out="${2:-}"; shift 2 ;;
      --include-keys) include_keys=1; shift ;;
      --force) force=1; shift ;;
      *) break ;;
    esac
  done
  ensure_dirs; validate_or_init_map
  local home; home="$(user_home)"
  [[ -n "$out" ]] || out="$home/agenix-export-$(date +%Y%m%d-%H%M%S).tar.age"
  [[ $force -eq 1 || ! -e "$out" ]] || die "output exists: $out (use --force)"

  if [[ ! -s "$PUB_COMBINED" && -s "$PUB_BREAK" ]]; then
    echo "WARN: $PUB_COMBINED missing; exporting encrypted only to break-glass recipient(s)"
  fi

  local work; work="$(mktemp -d -p "$RAMTMP")"; trap 'rm -rf "$work"' RETURN
  install -d -m 700 "$work/payload" "$work/keys"
  local manifest="$work/manifest.json"
  jq -n --arg created "$(date -Is)" '{version:1, created:$created, secrets:[]}' > "$manifest"

  while IFS= read -r row; do
    name="$(printf '%s' "$row" | base64 -d | jq -r '.key')"
    path="$(printf '%s' "$row" | base64 -d | jq -r '.value.agePath')"
    mode="$(printf '%s' "$row" | base64 -d | jq -r '.value.mode // empty')"
    owner="$(printf '%s' "$row" | base64 -d | jq -r '.value.owner // empty')"
    group="$(printf '%s' "$row" | base64 -d | jq -r '.value.group // empty')"
    [[ -f "$path" ]] || continue
    h="$(hash_name "$name")"
    cp -f -- "$path" "$work/payload/s_${h}.age"
    tmpm="$(mktemp -p "$RAMTMP")"
    jq --arg n "$name" --arg f "payload/s_${h}.age" --arg m "$mode" --arg o "$owner" --arg g "$group" \
       ' .secrets += [{name:$n,file:$f,mode:$m,owner:$o,group:$g}] ' \
       "$manifest" > "$tmpm"
    mv -f "$tmpm" "$manifest"
  done < <(jq -r 'to_entries[] | @base64' "$MAP")

  if [[ $include_keys -eq 1 ]]; then
    [[ -f "$PRIV_DEVICE" ]] || die "missing $PRIV_DEVICE for --include-keys"
    [[ -f "$PUB_COMBINED"  ]] || die "missing $PUB_COMBINED for --include-keys"
    install -m 600 "$PRIV_DEVICE" "$work/keys/private"
    install -m 644 "$PUB_COMBINED"  "$work/keys/public"
  fi

  ( cd "$work" && tar -cf - . ) | age -a -R "${PUB_COMBINED:-$PUB_BREAK}" -o "$out"
  chown "${SUDO_UID:-$(id -u)}":"${SUDO_GID:-$(id -g)}" "$out" 2>/dev/null || true
  printf 'OK: export written to %s\n' "$out"
}

cmd_import() { # import …
  local id="" archive="" replace_keys=1 force=0
  while [[ $# -gt 0 ]]; do
    case "$1" in
      --identity) id="${2:-}"; shift 2 ;;
      --replace-keys) replace_keys=1; shift ;;
      --no-replace-keys) replace_keys=0; shift ;;
      --force) force=1; shift ;;
      *) archive="${1:-}"; shift ;;
    esac
  done
  [[ -n "$id" && -f "$id" ]] || die "need --identity <key.txt>"
  [[ -n "$archive" && -f "$archive" ]] || die "need export file"
  ensure_dirs; validate_or_init_map

  local work; work="$(mktemp -d -p "$RAMTMP")"; trap 'rm -rf "$work"' RETURN
  umask 077
  age -d -i "$id" -o - < "$archive" | tar -C "$work" -xf -

  if [[ -f "$work/keys/private" && -f "$work/keys/public" && $replace_keys -eq 1 ]]; then
    install -m 600 "$work/keys/private" "$PRIV_DEVICE"
    install -m 644 "$work/keys/public"  "$PUB_COMBINED"
  fi

  [[ -f "$work/manifest.json" ]] || die "missing manifest in export"
  jq -e '.version==1 and (.secrets|type=="array")' "$work/manifest.json" >/dev/null || die "bad manifest"

  exec 9>"$LOCK"; flock -x 9
  while IFS= read -r line; do
    name="$(jq -r '.name' <<<"$line")"
    file="$(jq -r '.file' <<<"$line")"
    mode="$(jq -r '.mode // empty' <<<"$line")"
    owner="$(jq -r '.owner // empty' <<<"$line")"
    group="$(jq -r '.group // empty' <<<"$line")"
    [[ -n "$name" && -f "$work/$file" ]] || continue
    dest="$DEST_DIR/$name.age"
    if [[ -e "$dest" && $force -ne 1 ]]; then
      echo "skip existing $dest (use --force to overwrite)" >&2
    else
      install -m 600 "$work/$file" "$dest"
    fi
    tmp="$(mktemp -p "$RAMTMP")"
    jq --arg n "$name" --arg p "$dest" --arg m "$mode" --arg o "$owner" --arg g "$group" \
       ' .[$n] = {
           agePath: $p,
           mode:   (if $m=="" then "0400" else $m end),
           owner:  (if $o=="" then "root" else $o end),
           group:  (if $g=="" then "root" else $g end)
         } ' \
       "$MAP" > "$tmp"
    mv -f "$tmp" "$MAP"
  done < <(jq -c '.secrets[]' "$work/manifest.json")
  flock -u 9

  printf 'OK: import complete\n'
}

cmd_commit() { # commit …
  local args=()
  while [[ $# -gt 0 ]]; do
    case "$1" in
      --switch) args+=(--switch); shift ;;
      --flake)  args+=(--flake "${2:-}"); shift 2 ;;
      *) break ;;
    esac
  done
  do_commit "${args[@]}"
}

cmd_check() { # check …
  local break_key="" fail_fast=0
  while [[ $# -gt 0 ]]; do
    case "$1" in
      --break-key) break_key="${2:-}"; shift 2 ;;
      --fail-fast) fail_fast=1; shift ;;
      *) break ;;
    esac
  done
  ensure_dirs; validate_or_init_map

  local prompted_tmp=""
  if [[ -z "$break_key" ]]; then
    if get_break_key; then
      break_key="$BREAK_KEY_TMP"; prompted_tmp="$BREAK_KEY_TMP"
      trap '[[ -n "$prompted_tmp" ]] && shred -u "$prompted_tmp" 2>/dev/null || rm -f "$prompted_tmp" || true' RETURN
    fi
  fi

  if [[ -n "$break_key" ]]; then
    [[ -f "$break_key" ]] || die "no such break key: $break_key"
    local derived; derived="$(derive_pub_from_priv "$break_key")"
    [[ -n "$derived" ]] || die "could not derive public from $break_key"
    if [[ -s "$PUB_BREAK" ]]; then
      local match=0
      while read -r expected; do
        [[ -n "$expected" ]] || continue
        if [[ "$derived" == "$expected" ]]; then match=1; break; fi
      done < "$PUB_BREAK"
      [[ $match -eq 1 ]] || die "break-glass key DOES NOT MATCH any recipient in $PUB_BREAK"
      echo "OK: break-glass key matches an entry in $PUB_BREAK"
    else
      echo "WARN: $PUB_BREAK missing; cannot verify break-glass public(s)"
    fi
  fi

  local -a id_args=()
  [[ -n "$break_key" ]] && id_args+=(-i "$break_key")
  [[ -f "$PRIV_DEVICE" ]] && id_args+=(-i "$PRIV_DEVICE")
  local had_fail=0
  while read -r f; do
    [[ -f "$f" ]] || { echo "MISSING $f"; continue; }
    if AGE_IDENTITIES="" age -d "${id_args[@]}" -o /dev/null "$f" 2>/dev/null; then
      echo "OK   $f"
    else
      echo "FAIL $f"; had_fail=1
      [[ $fail_fast -eq 1 ]] && exit 2
    fi
  done < <(jq -r 'to_entries[].value.agePath' "$MAP")
  [[ $had_fail -eq 0 ]] || exit 2
  [[ -n "$prompted_tmp" ]] && shred -u "$prompted_tmp" 2>/dev/null || rm -f "$prompted_tmp" || true
}

cmd_rotate() { # rotate …
  local break_key="" gen_ident=0 force=0 include_break=1 extras=() extras_file="" old_ids=() commit_switch=0 commit_flake=""
  while [[ $# -gt 0 ]]; do
    case "$1" in
      --verify-break) break_key="${2:-}"; shift 2 ;;
      --generate-identity) gen_ident=1; shift ;;
      --force) force=1; shift ;;
      --include-break) include_break=1; shift ;;
      --no-include-break) include_break=0; shift ;;
      --extra-recipient) extras+=("${2:-}"); shift 2 ;;
      --extra-recipient-file) extras_file="${2:-}"; shift 2 ;;
      --old-identity) old_ids+=("${2:-}"); shift 2 ;;
      --switch) commit_switch=1; shift ;;
      --flake) commit_flake="${2:-}"; shift 2 ;;
      *) break ;;
    esac
  done

  ensure_dirs; validate_or_init_map

  local prompted_tmp=""
  if [[ -z "$break_key" ]]; then
    if get_break_key; then
      break_key="$BREAK_KEY_TMP"; prompted_tmp="$BREAK_KEY_TMP"
      trap '[[ -n "$prompted_tmp" ]] && shred -u "$prompted_tmp" 2>/dev/null || rm -f "$prompted_tmp" || true' RETURN
    else
      echo "NOTE: no break-glass key provided; continuing without it" >&2
    fi
  fi

  if [[ -n "$break_key" ]]; then
    [[ -f "$break_key" ]] || die "no such break key: $break_key"
    local derived; derived="$(derive_pub_from_priv "$break_key")"
    [[ -n "$derived" ]] || die "could not derive public from $break_key"
    if [[ -s "$PUB_BREAK" ]]; then
      local match=0
      while read -r expected; do
        [[ -n "$expected" ]] || continue
        if [[ "$derived" == "$expected" ]]; then match=1; break; fi
      done < "$PUB_BREAK"
      [[ $match -eq 1 ]] || die "break-glass key mismatch: not present in $(basename "$PUB_BREAK")"
      echo "OK: verified break-glass key against $(basename "$PUB_BREAK")"
    else
      echo "WARN: $PUB_BREAK missing; cannot verify break-glass public(s)"
    fi
  else
    echo "NOTE: --verify-break not provided; proceeding without verification"
  fi

  if [[ $gen_ident -eq 1 ]]; then
    if [[ -e "$PRIV_DEVICE" ]]; then
      if [[ $force -ne 1 ]]; then
        die "$PRIV_DEVICE exists (use --force to overwrite, a timestamped backup will be created)"
      fi
      cp -f "$PRIV_DEVICE" "$PRIV_DEVICE.bak.$(date +%s)"
    fi
    umask 077
    age-keygen -o "$PRIV_DEVICE"
    chmod 600 "$PRIV_DEVICE"
    echo "OK: generated new device identity at $PRIV_DEVICE"
  fi

  local recipients=()
  if [[ -f "$PRIV_DEVICE" ]]; then
    local devpub; devpub="$(derive_pub_from_priv "$PRIV_DEVICE")"
    [[ -n "$devpub" ]] && recipients+=("$devpub")
  fi
  if [[ $include_break -eq 1 && -s "$PUB_BREAK" ]]; then
    while read -r r; do [[ -n "$r" ]] && recipients+=("$r"); done < "$PUB_BREAK"
  fi
  for r in "${extras[@]:-}"; do [[ -n "$r" ]] && recipients+=("$r"); done
  if [[ -n "$extras_file" && -s "$extras_file" ]]; then
    while read -r line; do [[ -n "$line" ]] && recipients+=("$line"); done < "$extras_file"
  fi

  [[ ${#recipients[@]} -gt 0 ]] || die "no recipients to write to $PUB_COMBINED (need device pub and/or break-glass pub)"
  local tmp_pub; tmp_pub="$(mktemp -p "$RAMTMP")"
  printf '%s\n' "${recipients[@]}" | awk 'NF' | sort -u > "$tmp_pub"
  install -m 644 "$tmp_pub" "$PUB_COMBINED"; rm -f "$tmp_pub"
  echo "OK: wrote combined recipients to $PUB_COMBINED"

  local -a id_args=()
  [[ -n "$break_key" ]] && id_args+=(-i "$break_key")
  [[ -f "$PRIV_DEVICE" ]] && id_args+=(-i "$PRIV_DEVICE")
  for oi in "${old_ids[@]:-}"; do [[ -n "$oi" ]] && id_args+=(-i "$oi"); done

  local ok=0 fail=0 total=0
  while read -r F; do
    total=$((total+1))
    [[ -f "$F" ]] || { echo "SKIP missing $F"; continue; }
    T="$(mktemp -p "$RAMTMP")"
    if AGE_IDENTITIES="" age -d "${id_args[@]}" -o "$T" "$F" 2>/dev/null; then
      age -a -R "$PUB_COMBINED" -o "$F.new" "$T"
      mv -f "$F.new" "$F"; chmod 600 "$F"
      echo "OK  $F"; ok=$((ok+1))
    else
      echo "FAIL $F  (not decryptable with provided identities)"; fail=$((fail+1))
    fi
    rm -f "$T"
  done < <(jq -r 'to_entries[].value.agePath' "$MAP")

  echo "SUMMARY: ok=$ok fail=$fail total=$total"
  (( fail == 0 )) || exit 2

  if [[ $commit_switch -eq 1 || -n "$commit_flake" ]]; then
    if [[ $commit_switch -eq 1 ]]; then
      do_commit --switch ${commit_flake:+--flake "$commit_flake"}
    else
      do_commit ${commit_flake:+--flake "$commit_flake"}
    fi
  fi

  [[ -n "$prompted_tmp" ]] && shred -u "$prompted_tmp" 2>/dev/null || rm -f "$prompted_tmp" || true
}

usage() {
  cat <<'EOF'
Usage:
  secretsctl [--map <path>] <subcommand>

  secretsctl add [--stdin|--from-file <path>|--edit]
                 [--hash-sha512 | --hash-yescrypt | --htpasswd <user>]
                 [--commit] [--switch] [--flake <uri-or-path>] <name>
  secretsctl rm <name>
  secretsctl list
  secretsctl rename <old> <new>
  secretsctl export [--output <path>] [--include-keys] [--force]
  secretsctl import --identity <key.txt> <export.tar.age> [--replace-keys] [--force]
  secretsctl commit [--switch] [--flake <uri-or-path>]
  secretsctl check [--break-key <path>] [--fail-fast]
  secretsctl rotate [--verify-break <path>] [--generate-identity] [--force]
                    [--include-break|--no-include-break]
                    [--extra-recipient <age1..>]...
                    [--extra-recipient-file <file>]
                    [--old-identity <path>]...
                    [--switch] [--flake <uri-or-path>]
  secretsctl gen-ssh --name <secret> [--comment <ssh-comment>] [--type ed25519|rsa] [--bits N] [--pub-out <path>] [--commit] [--switch] [--flake <uri>]
EOF
}

# ---------- entry ----------
case "${1-}" in
  --map=*) MAP="${1#--map=}"; shift ;;
  --map)   MAP="${2-}"; shift 2 ;;
esac
resolve_map >/dev/null 2>&1 || true

for b in age age-keygen jq tar flock install sed sha256sum base64 awk; do need "$b"; done

sub="${1:-}"; shift || true
case "$sub" in
  add)     cmd_add "$@" ;;
  gen-ssh) cmd_gen_ssh "$@" ;;
  rm)      cmd_rm "$@" ;;
  list)    cmd_list "$@" ;;
  rename)  cmd_rename "$@" ;;
  export)  cmd_export "$@" ;;
  import)  cmd_import "$@" ;;
  commit)  cmd_commit "$@" ;;
  check)   cmd_check "$@" ;;
  rotate)  cmd_rotate "$@" ;;
  ""|-h|--help|help) usage ;;
  *) die "unknown subcommand: $sub (use --help)";;
esac

